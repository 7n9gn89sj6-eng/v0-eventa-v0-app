// safe array helper
const toArray = <T,>(v: T[] | T | null | undefined): T[] =>
  Array.isArray(v) ? v : v == null ? [] : [v];
export const runtime = 'nodejs'
import { type NextRequest, NextResponse } from "next/server"
import { z } from "zod"
import { neon } from "@neondatabase/serverless"
import { env } from "@/lib/env"

const EventSubmitSchema = z
  .object({
    title: z.string().min(2),
    description: z.string().default(""),
    start: z.coerce.date({ required_error: "Start date and time is required" }),
    end: z.coerce.date().optional(),
    timezone: z.string().optional(),
    location: z
      .object({
        name: z.string().optional(),
        address: z.string().optional(),
        lat: z.number().optional(),
        lng: z.number().optional(),
      })
      .optional(),
    organizer_name: z.string().optional(),
    organizer_contact: z.string().optional(),
    creatorEmail: z.string().email().optional(),
    imageUrl: z.string().url().optional().or(z.literal("")),
    externalUrl: z.string().url().optional().or(z.literal("")),
  })
  .refine((d) => !d.end || d.end > d.start, {
    path: ["end"],
    message: "End date must be after start date",
  })

function generateId() {
  return Date.now().toString(36) + Math.random().toString(36).substring(2)
}

export async function POST(request: NextRequest) {
  try {
    const body = await request.json()
    const validatedData = EventSubmitSchema.parse(body)

    const creatorEmail = validatedData.creatorEmail
    if (!creatorEmail) {
      return NextResponse.json({ error: "Creator email is required" }, { status: 400 })
    }

    const sql = neon(env.NEON_DATABASE_URL)

    let userId: string
    const existingUsers = await sql`
      SELECT id FROM "User" WHERE email = ${creatorEmail} LIMIT 1
    `

    if (existingUsers.length > 0) {
      userId = existingUsers[0].id
    } else {
      const userName = validatedData.organizer_name || creatorEmail.split("@")[0]
      const newUserId = generateId()

      await sql`
        INSERT INTO "User" (id, email, name, "createdAt", "updatedAt")
        VALUES (${newUserId}, ${creatorEmail}, ${userName}, NOW(), NOW())
      `
      userId = newUserId
    }

    const eventId = generateId()
    const address = validatedData.location?.address || ""
const rawAddress = (address ?? '') as string
const safeAddress = typeof rawAddress === "string" ? rawAddress : "";
const addressParts = safeAddress
  .split(",")
  .map((p) => p.trim())
  .filter(Boolean);
    const city = addressParts[1] || addressParts[0] || "Unknown"
    const country = addressParts[addressParts.length - 1] || "Australia"

    await sql`
      INSERT INTO "Event" (
        id,
        title,
        description,
        "startAt",
        "endAt",
        timezone,
        "venueName",
        address,
        city,
        country,
        "imageUrl",
        "externalUrl",
        "createdById",
        status,
        "createdAt",
        "updatedAt"
      )
      VALUES (
        ${eventId},
        ${validatedData.title},
        ${validatedData.description},
        ${validatedData.start.toISOString()},
        ${validatedData.end ? validatedData.end.toISOString() : validatedData.start.toISOString()},
        ${validatedData.timezone || "UTC"},
        ${validatedData.location?.name || null},
        ${address || null},
        ${city},
        ${country},
        ${validatedData.imageUrl || null},
        ${validatedData.externalUrl || null},
        ${userId},
        'DRAFT',
        NOW(),
        NOW()
      )
    `

    const token = generateId()
    const expires = new Date(Date.now() + 30 * 24 * 60 * 60 * 1000)

    await sql`
      INSERT INTO "EventEditToken" (id, "eventId", "tokenHash", expires, "createdAt")
      VALUES (${generateId()}, ${eventId}, ${token}, ${expires.toISOString()}, NOW())
    `

    console.log("[v0] Email disabled - Event created successfully, token generated but not emailed")

    const editUrl = `${env.NEXT_PUBLIC_APP_URL || "http://localhost:3000"}/event/confirm?token=${token}`

    return NextResponse.json({
      ok: true,
      eventId,
      token,
      editUrl,
      message: "Event created successfully!",
    })
  } catch (error) {
    console.error("Error in POST /api/events/submit:", error)

    if (error instanceof Error && error.message.includes("Environment validation failed")) {
      return NextResponse.json({ error: "Server configuration error. Please contact support." }, { status: 500 })
    }

    if (error instanceof z.ZodError) {
      return NextResponse.json({ error: "Validation failed", errors: error.issues }, { status: 400 })
    }

    return NextResponse.json(
      {
        error: error instanceof Error ? error.message : "Failed to submit event",
      },
      { status: 500 },
    )
  }
}
